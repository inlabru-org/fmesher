# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Compute sparse matrix inverse
#'
#' @param AA A sparse matrix
C_qinv <- function(AA) {
    .Call(`_fmesher_C_qinv`, AA)
}

#' @title Globe points
#'
#' @description
#' Create points on a globe
#'
#' @param globe integer; the number of edge subdivision segments, 1 or higher
#' @export
fmesher_globe_points <- function(globe) {
    .Call(`_fmesher_fmesher_globe_points`, globe)
}

#' @title Refined Constrained Delaunay Triangulation
#'
#' @description
#' (...)
#'
#' @param options list of triangulation options
#' @param loc numeric matrix; initial points to include
#' @param tv 3-column integer matrix with 0-based vertex indices for each triangle
#' @param boundary 2-column integer matrix with 0-based vertex indices for each
#' boundary edge constrain
#' @param interior 2-column integer matrix with 0-based vertex indices for each
#' interior edge constraint
#' @param boundary_grp integer vector with group labels
#' @param interior_grp integer vector with group labels
#' @examples
#' m <- fmesher_rcdt(list(cet_margin = 1), matrix(0, 1, 2))
#' @export
fmesher_rcdt <- function(options, loc, tv = NULL, boundary = NULL, interior = NULL, boundary_grp = NULL, interior_grp = NULL) {
    .Call(`_fmesher_fmesher_rcdt`, options, loc, tv, boundary, interior, boundary_grp, interior_grp)
}

#' @title Barycentric coordinate computation
#'
#' @description
#' (...)
#'
#' @param loc numeric matrix; coordinates of points to locate in the mesh
#' @param mesh_loc numeric matrix; mesh vertex coordinates
#' @param mesh_tv 3-column integer matrix with 0-based vertex indices for each triangle
#' @param options list of triangulation options
#' @examples
#' m <- fmesher_rcdt(list(cet_margin = 1), matrix(0, 1, 2))
#' b <- fmesher_bary(matrix(c(0.5, 0.5), 1, 2),
#'                   m$s,
#'                   m$tv,
#'                   list())
#' @export
fmesher_bary <- function(loc, mesh_loc, mesh_tv, options) {
    .Call(`_fmesher_fmesher_bary`, loc, mesh_loc, mesh_tv, options)
}

#' @title Finite element matrix computation
#'
#' @description
#' (...)
#'
#' @param mesh_loc numeric matrix; mesh vertex coordinates
#' @param mesh_tv 3-column integer matrix with 0-based vertex indices for each triangle
#' @param options list of triangulation options (`sphere_tolerance`)
#' @examples
#' m <- fmesher_rcdt(list(cet_margin = 1), matrix(0, 1, 2))
#' b <- fmesher_fem(m$s, m$tv, fem_order_max = 2, list())
#' @export
fmesher_fem <- function(mesh_loc, mesh_tv, fem_order_max, options) {
    .Call(`_fmesher_fmesher_fem`, mesh_loc, mesh_tv, fem_order_max, options)
}

#' @title Test the matrix I/O system
#'
#' @param args_input Input argument list
#' @examples
#' A <- Matrix::sparseMatrix(i=1:4,j=4:1,x=2:5,dims=c(4,4))
#' inp <- list(
#'   A = fm_as_dgTMatrix(A),
#'   Bd = matrix((11:22)+0.5,4,3),
#'   Bi = matrix(121L:132L,4,3),
#'   B1d=as.matrix((31:34)+0.5),
#'   B1i=as.matrix(41L:44L),
#'   Ad = fm_as_fmesher_sparse(A)
#' )
#' inp[["BdM"]] <- as(inp[["Bd"]], "unpackedMatrix")
#' out <- C_matrixio_test2(args_input = inp)
#' str(out)
#' @export
C_matrixio_test2 <- function(args_input) {
    .Call(`_fmesher_C_matrixio_test2`, args_input)
}

#' @title Test the matrix I/O system
#'
#' @param args_input Input argument list
#' @examples
#' A <- Matrix::sparseMatrix(i=1:4,j=4:1,x=2:5,dims=c(4,4))
#' out <- C_matrixio_test(args_input=list(
#'   A = fm_as_dgTMatrix(A),
#'   Bd = matrix((11:22)+0.5,4,3),
#'   Bi = matrix(121L:132L,4,3),
#'   B1d=as.matrix((31:34)+0.5),
#'   B1i=as.matrix(41L:44L),
#'   Ad = fm_as_fmesher_sparse(A)
#' ))
#' Aout <- fm_as_dgTMatrix(out[["Ad"]])
#' A
#' Aout
#' @export
C_matrixio_test <- function(args_input) {
    .Call(`_fmesher_C_matrixio_test`, args_input)
}

